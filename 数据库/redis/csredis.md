### 什么是nosql

- 不仅仅是数据
- 没有固定的查询语句，数据没有固定的结构
- 数据之间没有关系，不用设计表
- 数据的储存方式多样，（键值对，文档，图形存储等）
- 只要保证最终一致性就可以了
- 高性能，高可用，易扩展



### Redis是单线程

- redis是基于内存的，cpu不是性能瓶颈，redis的性能瓶颈是根据机器的内存和网络带宽
- 多线程cpu会进行上下问切换，非常的耗时，对于内存系统来说，如果没有上下文切换就是效率最高的，多次读写都是在一个cpu上进行，在内存相同的情况下，单线程是最佳方案



### Redis 操作命令

#### String

```
setex key 过期时间 value # 设置过期时间
expire key 过期时间
setnx key value # 如果key存在则不设置
getset key value # 先get然后在set 如果存在则返回上set之前的值，并设置成新值
```

#### List

````
队列
lpush，rpop
栈
lpush，lpop
````

#### Set

```
SRANDMEMBER myset 2 # 随机抽选出指定个数的元素
```

#### Zset

```
ZRANGEBYSCORE key min max #排序
ZRANGEBYSCORE salary -inf +inf withscores # 显示全部的用户并且附带成绩，从小到大
```



### 三种特殊的数据类型

#### **Geospatial** 

可以推算地理位置信息，两地之间据里，方圆几里的人

#### **Hyperloglog**

基数

#### **Bitmap**

Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！



### 事务

Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按

照顺序执行！

Redis事务没有没有隔离级别的概念！

所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec

Redis单条命令式保存原子性的，但是事务不保证原子性！

编译型异常（命令错误），事务中所有的指令都不会执行

运行时异常（I/O，语法错误），事务中除了有错误的那一行，其他的命令都会执行

#### 悲观锁

- 无论什么时候都会加锁

#### 乐观锁

- 认为什么时候都不会出问题，所以不会上锁，更新数据的时候会去判断在此期间是否有人修改过这个数据
- 获取version
- 更新的时候比较version

可以使用watch当作redis的乐观锁

```
127.0.0.1:6379> watch money # 监视 money OK
127.0.0.1:6379> multi OK
127.0.0.1:6379> DECRBY money 10 QUEUED
127.0.0.1:6379> INCRBY out 10 QUEUED 
127.0.0.1:6379> exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失 败！(nil)
```



### 哨兵模式

能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。

哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。当哨兵监测到master宕机，会自动将slave切换成master，然后通过**发布订阅模式**通知其他的从服务器，修改配置文件，让它们切换主机

多哨兵模式

各个哨兵之间还会进行监控，假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为**主观下线**。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为

**客观下线**。



### 缓存穿透

- 概述

当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。

- 解决方案

布隆过滤器

缓存空对象



### 缓存击穿

- 概述

当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大。

- 解决方案

设置热点数据永不过期

加互斥锁（每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。）



### 缓存雪崩

- 概述

是指在某一个时间段，缓存集中过期失效。Redis 宕机

- 解决方案

redis高可用

限流降级

数据预热

