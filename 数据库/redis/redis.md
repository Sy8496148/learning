### redis的持久化机制
redis提供了两种持久化的机制RDB，AOF
RDB
开启关闭：默认开启
同步机制：在指定的时间内发生了一个（or多个）写操作就同步一次
储存的内容：具体的值
优点：
* 储存的文件是经过压缩，体积小
* 因为储存的是具体的值所以恢复快
* 适用于备份
缺点：
* 每次同步的时候都是会同步所有的数据，每次隔5分钟同步一次，如果服务器挂掉了，就有可能造成数据的丢失
* 数据在保存到rdb的时候，redis会fork出一个子进程来同步，数据比较大的时候，会比较耗时间

AOF
开启关闭：修改redis.conf文件，appendonly
同步机制：每秒同步或者每次操作后同步
储存的内容：储存的是命令，不会压缩
优点：
* 每秒保存一次数据，即使服务器发生故障也不会造成数据的丢失
* redis命令会直接追加到aof文件后面，因此每次备份的时候的时候只要追加数据就可以了
* aof文件大了，redis会进行重写，只保留最小的命令集合
缺点：
* aof文件没有被压缩，因此aof文件的体积比较大
* aof每秒中都要写入备份，因此如果并发量较大，就会造成效率慢的问题
* aof文件储存的是命令，灾难恢复的速度不及rdb



### rehash的解释：
在创建hashMAP的时候可以设置来个参数，一般默认
初始化容量：创建hash表时桶的数量
负载因子：负载因子=map的size/初始化容量
当hash表中的负载因子达到负载极限的时候，hash表会自动成倍的增加容量（桶的数量），并将原有的对象
重新的分配并加入新的桶内，这称为rehash。这个过程是十分耗性能的，一般不要
一般建议设置比较大的初始化容量，防止rehash，但是也不能设置过大，初始化容量过大 浪费空间



### redis文件处理器的四个组成部分：
套接字 >> IO多路复用程序 >> 文件分派器  >> 事件处理器
redis中io多路复用器模块是单线程执行，事件处理器也是单线程执行，两个线程不一样，依靠队列保证顺序。这样的好处是io多路复用线程接受和响应 和事件处理之间不会来回切换上下文进行处理。



### redis的淘汰机制
noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。
allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
allkeys-random: 所有key通用; 随机删除一部分 key。
volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。



### redis冷热数据

redis冷热数据的交换
热数据：将所有的Key都认为是热数据
冷数据：对于Value部分，在内存不足的情况下，实例本身会根据最近访问时间，访问频度，Value大小等维度选取出部分value作为冷数据后台异步存储到磁盘上直到内存小于制定阈值为止。

认为key都是热数据的原因
1，Key的访问频度比Value要高很多。
2，作为KV数据库，通常的访问请求都需要先查找Key确认Key是否存在，而要确认一个key不存在，就需要以某种形式检查所有Key的集合。在内存中保留所有Key，可以保证key的查找速度与纯内存版完全一致。
3，Key的大小占比很低。一般的value都比key的值要大

Redis混合存储实例的适用场景
1，数据访问不均匀，存在热点数据；
2，内存不足以放下所有数据，且Value较大(相对于Key而言)

冷热数据的识别
当内存不足时的情况下，实例会按照最近访问时间，访问频度，value大小等维度计算出value的权重，将权重最低的value存储到磁盘上并从内存中删除。
冷热数据识别时采用和Redis类似的近似计算方法,支持多种策略, 通过随机采样小部分数据来降低CPU和内存消耗，通过eviction pool利用采样历史信息来辅助提高准确率。


冷热数据转换过程：
冷数据 --> 热数据
异步：
1，主线程在执行前，判断key是否在内存中
2，如果不在，则生成数据加载任务并挂起当前线程，去执行其他线程
3，后台线程执行完成数据加载任务后通知主线程
4，主线程继续执行上次未完成的任务，并且更新访问的key的value值
同步：
如果发现key不在内存中就，直接启动数据加载任务，然后更新key的值返回给当前线程

热数据 --> 冷数据
异步：
1，主线程在内存接近最大值时，生成一系列数据换出任务；
2，后台线程执行这些数据换出任务，执行完毕之后通知主线程；
3，主线程更新释放内存中的value，更新内存中数据字典中的value为一个简单的元信息；
同步：
如果写入流量过大，异步方式来不及换出数据，导致内存超出最大规格内存。主线程将直接执行数据换出任务，达到变相限流的目的。