### MYSQL左连接，右连接，内连接

- 右连接

  select * from table_a a right left join table_b b on a.id =b.id;
  a表只会连接符合条件的结果（a表记录不全的地方用NULL表示），b表会显示所有的搜索结果

- 左连接

  select * from table_a a left join table_b b on a.id = b.id;
  a表会显示所有的搜索结果，b表只会链接符合条件的结果（记录不全的地方显示NULL）

- 内连接

  select * from table_a a inner join table_b b on a.id = b.id

  A表的所有行交上B表的所有行得出的结果集



### SQL依赖注入

通过参数化消除SQL依赖注入，当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击攻击者可能会通过恶意sql命令，获得对数据库的访问权限，就可以对网站数据库中的数据进行破坏
解决方案：参数化为我们提供了消除这种误解的能力。在遇到参数时，不管输入任何值，都将整个值作为参数的值，而不是原始 SQL 文本的一部分。



### mysql高并发的处理方法

一，运用缓存 redis memcached
二，业务拆分 分表
三 ，主从复制，读写分离
主服务器主要用于处理（增删改）
从服务器主要用于处理（查）
MySQL主从复制的原理：数据复制的实际就是Slave从Master获取Binary log文件，然后再本地镜像的执行日志中记录的操作。由于主从复制的过程是异步的，因此Slave和Master之间的数据有可能存在延迟的现象，此时只能保证数据最终的一致性。
四，分库分表



### mysql唯一索引与普通索引的区别：

一、创建索引语句差异
ALTER TABLE `tt_test`
ADD INDEX（UNIQUE ） `k_title` (`title`) USING BTREE ;
二、查询语句差异
select  id  from tt_test where title='1'
普通索引查询
普通索引在找到满足itle=‘1’ 的第一个记录后，需要查询下一个记录，直到碰到第一个不满足
itle=‘1’ 的条件的记录。
唯一索引查询
对于唯一索引，查找到第一个满足条件的记录后，就会停止继续检索。
三、更新语句差异
唯一索引会先判断更新的时候数据是否会重复



### 索引创建的原则

更新频繁的列不应设置索引
数据量小的表不要使用索引（毕竟总共2页的文档，还要目录吗？）
重复数据多的字段不应设为索引（比如性别，只有男和女，一般来说：重复的数据超过百分之15就不该建索引）
首先应该考虑对where 和 order by 涉及的列上建立索引



### mysql索引数据结构

mysql索引用B树（B+） 而不是用二叉树,
磁盘的寻址次数少，B数的一个节点可以储存两个或者多个元素，
而二叉树每个节点只存取一个元素，这样就减少了寻址的次数

mysql用B+树，mongo用B树
B树特点：
树内的每个节点都存储数据
叶子节点之间无指针相邻

B+树特点：
数据只出现在叶子节点
所有叶子节点增加了一个链指针

B+树的叶子节点上有指针进行相连，因此在做数据遍历的时候，只需要对叶子节点进行遍历即可，这个特性使得B+树非常适合做范围查询，而B树中各节点之间没有指针相邻，因此B树不适合做一些数据遍历操作。Mysql中数据遍历操作比较多，所以用B+树作为索引结构。而Mongodb是做单一查询比较多，数据遍历操作比较少，所以用B树作为索引结构。



### mysql的乐观锁和悲观锁

悲观锁：
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。
使用场景：
但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

乐观锁：
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
使用场景：
乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。



### 快照读与当前读

快照读，读取的是记录的可见版本（可能是历史版本，即最新的数据可能正在被当前执行的事务并发修改），不会对返回的记录加锁。
在MySQL InnoDB中，简单的select操作，如 select * from table where 。。。 都属于快照读；

当前读，读取的是记录的最新版本，并且会对返回的记录加锁，保证其他事务不会并发修改这条记录。
前读的包含以下操作：
insert, update, delete操作
select * from table where ? for update; （推荐使用）
（加X锁：写的时候不能读（一次最多只能有一个线程对同一份数据进行写操作，即排它锁，X锁）
select * from table where ? lock in share mode; 
（加S锁：读的时候不能写（允许多个线程同时读，即共享锁，S锁））



### mysql的三大范式
1，原子性不可拆分，保证数据列不能够拆分
2，唯一性，保证数据列必须跟主键相关
3，保证数据列必须跟主键直接相关而不可以根据其他列的值计算出来



### mysql主从复制的原理
主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。
在这个过程中从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。
而且会存在一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。
所以mysql实际上在这一块有两个机制，
一个是半同步复制，用来解决主库数据丢失问题；
一个是并行复制，用来解决主从同步延时问题。
这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relaylog之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。
所谓并行复制，指的是从库开启多个线程，并行读取relaylog中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

